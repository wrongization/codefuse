# 数据库操作实现文档

本文档描述 CodeFuse 项目中的数据库层实现细节，包括：

1. 数据库表定义（根据 `app/models.py` 推导的建表语句）
2. 各系统功能在数据库端的操作（原生SQL语句）

---

## 1. 数据库表定义

本节根据 `backend/app/models.py` 中的 SQLAlchemy ORM 模型定义，推导出等价的 MySQL 建表语句。系统共包含 **13 张表**（6 张实体表 + 7 张联系表）。

### 1.1 实体表

#### ① 用户表 (user)

```sql
CREATE TABLE `user` (
    `user_id` INT NOT NULL AUTO_INCREMENT,
    `username` VARCHAR(255) NOT NULL,
    `password` VARCHAR(255) NOT NULL COMMENT '存储哈希后的密码',
    `email` VARCHAR(255) NOT NULL,
    `school` VARCHAR(255) NULL,
    `rating` INT NOT NULL DEFAULT 0,
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `role` VARCHAR(50) NOT NULL DEFAULT 'user' COMMENT 'user 或 admin',
    `avatar` VARCHAR(255) NULL COMMENT '用户头像URL',
    PRIMARY KEY (`user_id`),
    UNIQUE KEY `uk_username` (`username`),
    UNIQUE KEY `uk_email` (`email`),
    INDEX `idx_role` (`role`),
    INDEX `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ② 题目表 (problem)

```sql
CREATE TABLE `problem` (
    `problem_id` INT NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(255) NOT NULL,
    `description` TEXT NOT NULL,
    `input_format` TEXT NOT NULL,
    `output_format` TEXT NOT NULL,
    `sample_input` TEXT NOT NULL,
    `sample_output` TEXT NOT NULL,
    `time_limit` INT NOT NULL COMMENT '时间限制（毫秒）',
    `memory_limit` INT NOT NULL COMMENT '内存限制（KB）',
    `difficulty` VARCHAR(50) NOT NULL COMMENT 'easy, medium, hard',
    `tags` VARCHAR(255) NULL,
    `creator_id` INT NOT NULL,
    `test_cases` JSON NULL COMMENT '测试用例（JSON数组）',
    `visible` TINYINT(1) NOT NULL DEFAULT 1 COMMENT '是否对普通用户可见',
    PRIMARY KEY (`problem_id`),
    INDEX `idx_difficulty` (`difficulty`),
    INDEX `idx_creator` (`creator_id`),
    INDEX `idx_visible` (`visible`),
    CONSTRAINT `fk_problem_creator` FOREIGN KEY (`creator_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=10000 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**说明**：`AUTO_INCREMENT=10000` 确保公开题目ID从10000开始，1-9999为比赛专用保留ID区间。

#### ③ 比赛表 (contest)

```sql
CREATE TABLE `contest` (
    `contest_id` INT NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(255) NOT NULL,
    `description` TEXT NOT NULL,
    `start_time` DATETIME NOT NULL,
    `end_time` DATETIME NOT NULL,
    `creator_id` INT NOT NULL,
    `problems_published` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '题目是否已发布到公开题库',
    PRIMARY KEY (`contest_id`),
    INDEX `idx_start_time` (`start_time`),
    INDEX `idx_end_time` (`end_time`),
    INDEX `idx_creator` (`creator_id`),
    CONSTRAINT `fk_contest_creator` FOREIGN KEY (`creator_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ④ 消息表 (message)

```sql
CREATE TABLE `message` (
    `message_id` INT NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(255) NULL COMMENT '标题（可选，主要用于话题贴）',
    `content` TEXT NOT NULL,
    `creator_id` INT NOT NULL,
    `message_type` VARCHAR(50) NOT NULL COMMENT 'topic 或 private',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`message_id`),
    INDEX `idx_message_type` (`message_type`),
    INDEX `idx_creator` (`creator_id`),
    INDEX `idx_created_at` (`created_at`),
    CONSTRAINT `fk_message_creator` FOREIGN KEY (`creator_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ⑤ 提交记录表 (submission)

```sql
CREATE TABLE `submission` (
    `submission_id` INT NOT NULL AUTO_INCREMENT,
    `problem_id` INT NOT NULL,
    `contest_id` INT NULL COMMENT '比赛ID（可空，非比赛提交为NULL）',
    `code` TEXT NOT NULL,
    `language` VARCHAR(50) NOT NULL COMMENT 'python, cpp, java, c',
    `status` VARCHAR(50) NOT NULL COMMENT 'accepted, wrong_answer, time_limit_exceeded 等',
    `exec_time` INT NOT NULL COMMENT '执行时间（毫秒）',
    `exec_memory` INT NOT NULL COMMENT '内存使用（KB）',
    `submitted_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `judge_results` JSON NULL COMMENT '评测结果（JSON数组）',
    PRIMARY KEY (`submission_id`),
    INDEX `idx_problem` (`problem_id`),
    INDEX `idx_contest` (`contest_id`),
    INDEX `idx_status` (`status`),
    INDEX `idx_submitted_at` (`submitted_at`),
    CONSTRAINT `fk_submission_problem` FOREIGN KEY (`problem_id`) 
        REFERENCES `problem` (`problem_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_submission_contest` FOREIGN KEY (`contest_id`) 
        REFERENCES `contest` (`contest_id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ⑥ 活动日志表 (activity_log)

```sql
CREATE TABLE `activity_log` (
    `log_id` INT NOT NULL AUTO_INCREMENT,
    `user_id` INT NULL COMMENT '执行操作的用户（可空，支持系统级操作）',
    `action_type` VARCHAR(50) NOT NULL COMMENT 'create, update, delete, submit',
    `entity_type` VARCHAR(50) NOT NULL COMMENT 'user, problem, contest, submission',
    `entity_id` INT NULL COMMENT '被操作实体的ID',
    `description` TEXT NOT NULL COMMENT '操作描述',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`log_id`),
    INDEX `idx_user` (`user_id`),
    INDEX `idx_action_type` (`action_type`),
    INDEX `idx_entity_type` (`entity_type`),
    INDEX `idx_created_at` (`created_at`),
    CONSTRAINT `fk_activity_log_user` FOREIGN KEY (`user_id`) 
        REFERENCES `user` (`user_id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 1.2 联系表

#### ① 比赛-题目联系表 (contest_problem)

```sql
CREATE TABLE `contest_problem` (
    `contest_id` INT NOT NULL,
    `problem_id` INT NOT NULL,
    PRIMARY KEY (`contest_id`, `problem_id`),
    INDEX `idx_problem` (`problem_id`),
    CONSTRAINT `fk_cp_contest` FOREIGN KEY (`contest_id`) 
        REFERENCES `contest` (`contest_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_cp_problem` FOREIGN KEY (`problem_id`) 
        REFERENCES `problem` (`problem_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ② 比赛-用户联系表 (contest_user)

```sql
CREATE TABLE `contest_user` (
    `contest_id` INT NOT NULL,
    `user_id` INT NOT NULL,
    PRIMARY KEY (`contest_id`, `user_id`),
    INDEX `idx_user` (`user_id`),
    CONSTRAINT `fk_cu_contest` FOREIGN KEY (`contest_id`) 
        REFERENCES `contest` (`contest_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_cu_user` FOREIGN KEY (`user_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ③ 消息-题目联系表 (message_problem)

```sql
CREATE TABLE `message_problem` (
    `message_id` INT NOT NULL,
    `problem_id` INT NOT NULL,
    PRIMARY KEY (`message_id`, `problem_id`),
    INDEX `idx_problem` (`problem_id`),
    CONSTRAINT `fk_mp_message` FOREIGN KEY (`message_id`) 
        REFERENCES `message` (`message_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_mp_problem` FOREIGN KEY (`problem_id`) 
        REFERENCES `problem` (`problem_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ④ 消息-接收者联系表 (message_recipient)

```sql
CREATE TABLE `message_recipient` (
    `message_id` INT NOT NULL,
    `recipient_user_id` INT NOT NULL,
    PRIMARY KEY (`message_id`, `recipient_user_id`),
    INDEX `idx_recipient` (`recipient_user_id`),
    CONSTRAINT `fk_mr_message` FOREIGN KEY (`message_id`) 
        REFERENCES `message` (`message_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_mr_user` FOREIGN KEY (`recipient_user_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ⑤ 题目-提交联系表 (problem_submission)

```sql
CREATE TABLE `problem_submission` (
    `problem_id` INT NOT NULL,
    `submission_id` INT NOT NULL,
    PRIMARY KEY (`problem_id`, `submission_id`),
    INDEX `idx_ps_submission` (`submission_id`),
    CONSTRAINT `fk_ps_problem` FOREIGN KEY (`problem_id`)
        REFERENCES `problem` (`problem_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_ps_submission` FOREIGN KEY (`submission_id`)
        REFERENCES `submission` (`submission_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ⑥ 用户-提交联系表 (user_submission)

```sql
CREATE TABLE `user_submission` (
    `user_id` INT NOT NULL,
    `submission_id` INT NOT NULL,
    PRIMARY KEY (`user_id`, `submission_id`),
    INDEX `idx_submission` (`submission_id`),
    CONSTRAINT `fk_us_user` FOREIGN KEY (`user_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_us_submission` FOREIGN KEY (`submission_id`) 
        REFERENCES `submission` (`submission_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### ⑦ 好友关系表 (friendship)

```sql
CREATE TABLE `friendship` (
    `friendship_id` INT NOT NULL AUTO_INCREMENT,
    `user_id` INT NOT NULL COMMENT '发起者',
    `friend_id` INT NOT NULL COMMENT '接收者',
    `status` ENUM('pending', 'accepted', 'rejected', 'blocked') NOT NULL DEFAULT 'pending',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`friendship_id`),
    UNIQUE KEY `uk_user_friend` (`user_id`, `friend_id`),
    INDEX `idx_friend` (`friend_id`),
    INDEX `idx_status` (`status`),
    CONSTRAINT `fk_friendship_user` FOREIGN KEY (`user_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE,
    CONSTRAINT `fk_friendship_friend` FOREIGN KEY (`friend_id`) 
        REFERENCES `user` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

---

## 2. 各系统功能的数据库操作

本节列出系统中所有功能及其对应的原生SQL语句实现。系统严格按照以下原则设计：
- **模型定义**：使用SQLAlchemy的ORM模型（models.py）仅用于建表
- **数据操作**：所有增删改查操作均使用原生SQL语句实现

### 2.1 用户管理模块 (users.py)

#### 2.1.1 用户注册
**功能**：创建新用户账号

**SQL语句**：
```sql
-- 检查用户名是否存在
SELECT user_id FROM user WHERE username = :username;

-- 检查邮箱是否存在
SELECT user_id FROM user WHERE email = :email;

-- 插入新用户
INSERT INTO user (username, password, email, school, rating, created_at, role)
VALUES (:username, :password, :email, :school, :rating, :created_at, :role);

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, :action_type, :entity_type, :entity_id, :description, :created_at);

-- 查询新创建的用户
SELECT * FROM user WHERE user_id = :user_id;
```

#### 2.1.2 用户登录
**功能**：用户身份验证

**SQL语句**：
```sql
-- 查询用户信息进行验证（支持用户名或邮箱登录）
SELECT * FROM user WHERE username = :identifier;
SELECT * FROM user WHERE email = :identifier;
```

#### 2.1.3 获取用户列表
**功能**：查询用户列表，支持搜索、筛选、排序和分页

**SQL语句**：
```sql
-- 基础查询（带条件动态拼接）
SELECT * FROM user 
WHERE 1=1
  AND (username LIKE :search OR email LIKE :search OR school LIKE :search)  -- 可选搜索
  AND role = :role  -- 可选角色筛选
ORDER BY created_at DESC  -- 可选排序（created_at/username/rating）
LIMIT :limit OFFSET :offset;
```

#### 2.1.4 获取单个用户信息
**功能**：根据ID查询用户详细信息

**SQL语句**：
```sql
SELECT * FROM user WHERE user_id = :user_id;
```

#### 2.1.5 更新用户信息
**功能**：修改用户资料（用户名、邮箱、学校、密码等）

**SQL语句**：
```sql
-- 查询用户是否存在
SELECT * FROM user WHERE user_id = :user_id;

-- 检查新用户名是否被占用
SELECT user_id FROM user WHERE username = :username AND user_id != :user_id;

-- 检查新邮箱是否被占用
SELECT user_id FROM user WHERE email = :email AND user_id != :user_id;

-- 更新用户信息（动态拼接字段）
UPDATE user 
SET username = :username, email = :email, school = :school, password = :password
WHERE user_id = :user_id;
```

#### 2.1.6 删除用户
**功能**：管理员删除用户，级联删除所有相关数据

**SQL语句**：
```sql
-- 查询用户是否存在
SELECT username, role FROM user WHERE user_id = :user_id;

-- 获取用户的所有提交ID
SELECT submission_id FROM user_submission WHERE user_id = :user_id;

-- 删除用户-提交关联
DELETE FROM user_submission WHERE user_id = :user_id;

-- 删除提交记录
DELETE FROM submission WHERE submission_id IN (:submission_id_list);

-- 删除比赛参与记录
DELETE FROM contest_user WHERE user_id = :user_id;

-- 删除消息接收记录
DELETE FROM message_recipient WHERE recipient_user_id = :user_id;

-- 获取用户创建的消息ID
SELECT message_id FROM message WHERE creator_id = :user_id;

-- 删除消息-题目关联
DELETE FROM message_problem WHERE message_id IN (:message_id_list);

-- 删除消息-接收者关联
DELETE FROM message_recipient WHERE message_id IN (:message_id_list);

-- 删除用户创建的消息
DELETE FROM message WHERE creator_id = :user_id;

-- 删除好友关系
DELETE FROM friendship WHERE user_id = :user_id OR friend_id = :user_id;

-- 删除用户本身
DELETE FROM user WHERE user_id = :user_id;

-- 记录删除日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:admin_id, 'delete', 'user', :user_id, :description, :created_at);
```

#### 2.1.7 用户统计
**功能**：获取用户的提交数、通过题数和参与比赛数

**SQL语句**：
```sql
-- 提交总数
SELECT COUNT(*) as cnt FROM user_submission WHERE user_id = :user_id;

-- 参与比赛数
SELECT COUNT(*) as cnt FROM contest_user WHERE user_id = :user_id;

-- 解题数（仅统计题库提交，排除比赛提交）
SELECT COUNT(DISTINCT s.problem_id) as cnt
FROM submission s
INNER JOIN user_submission us ON s.submission_id = us.submission_id
WHERE us.user_id = :user_id 
  AND (s.status = 'Accepted' OR s.status = 'accepted') 
  AND s.contest_id IS NULL;
```

#### 2.1.8 上传用户头像
**功能**：用户上传头像图片

**SQL语句**：
```sql
-- 查询用户当前头像
SELECT avatar FROM user WHERE user_id = :user_id;

-- 更新用户头像URL
UPDATE user SET avatar = :avatar WHERE user_id = :user_id;
```

---

### 2.2 题目管理模块 (problems.py)

#### 2.2.1 创建题目
**功能**：创建新题目（支持公开题目和比赛专用题目）

**SQL语句**：
```sql
-- 为比赛专用题目分配保留ID（1-9999）
SELECT problem_id FROM problem WHERE problem_id < 10000;

-- 插入新题目（手动指定ID用于比赛专用题目）
INSERT INTO problem (
    problem_id, title, description, input_format, output_format,
    sample_input, sample_output, time_limit, memory_limit,
    difficulty, tags, creator_id, test_cases, visible
) VALUES (
    :problem_id, :title, :description, :input_format, :output_format,
    :sample_input, :sample_output, :time_limit, :memory_limit,
    :difficulty, :tags, :creator_id, :test_cases, :visible
);

-- 或插入公开题目（自动递增ID>=10000）
INSERT INTO problem (
    title, description, input_format, output_format,
    sample_input, sample_output, time_limit, memory_limit,
    difficulty, tags, creator_id, test_cases, visible
) VALUES (
    :title, :description, :input_format, :output_format,
    :sample_input, :sample_output, :time_limit, :memory_limit,
    :difficulty, :tags, :creator_id, :test_cases, 1
);

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, 'create', 'problem', :problem_id, :description, :created_at);
```

#### 2.2.2 获取题目列表
**功能**：查询题目列表，支持权限过滤、搜索、筛选、排序

**SQL语句**：
```sql
-- 基础查询（动态拼接条件）
SELECT * FROM problem
WHERE problem_id >= 10000  -- 非管理员只能看公开题目
  AND difficulty = :difficulty  -- 可选难度筛选
  AND title LIKE :search  -- 可选标题搜索
  AND tags LIKE :tag  -- 可选标签筛选
ORDER BY problem_id DESC  -- 可选排序
LIMIT :limit OFFSET :offset;

-- 查询用户是否通过了题目（用于is_solved状态）
SELECT s.submission_id 
FROM submission s
INNER JOIN user_submission us ON s.submission_id = us.submission_id
WHERE us.user_id = :user_id 
  AND s.problem_id = :problem_id
  AND s.contest_id IS NULL
  AND s.status = 'accepted'
LIMIT 1;
```

#### 2.2.3 获取单个题目
**功能**：根据ID查询题目详情

**SQL语句**：
```sql
SELECT * FROM problem WHERE problem_id = :problem_id;
```

#### 2.2.4 更新题目
**功能**：修改题目信息

**SQL语句**：
```sql
-- 查询题目是否存在
SELECT * FROM problem WHERE problem_id = :problem_id;

-- 更新题目（动态拼接字段）
UPDATE problem
SET title = :title,
    description = :description,
    input_format = :input_format,
    output_format = :output_format,
    sample_input = :sample_input,
    sample_output = :sample_output,
    time_limit = :time_limit,
    memory_limit = :memory_limit,
    difficulty = :difficulty,
    tags = :tags,
    test_cases = :test_cases
WHERE problem_id = :problem_id;

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, 'update', 'problem', :problem_id, :description, :created_at);
```

#### 2.2.5 删除题目
**功能**：管理员删除题目，级联删除相关数据

**SQL语句**：
```sql
-- 查询题目是否存在
SELECT title FROM problem WHERE problem_id = :problem_id;

-- 获取题目的所有提交ID
SELECT submission_id FROM submission WHERE problem_id = :problem_id;

-- 删除用户-提交关联
DELETE FROM user_submission WHERE submission_id IN (:submission_id_list);

-- 删除提交记录
DELETE FROM submission WHERE problem_id = :problem_id;

-- 删除比赛-题目关联
DELETE FROM contest_problem WHERE problem_id = :problem_id;

-- 删除消息-题目关联
DELETE FROM message_problem WHERE problem_id = :problem_id;

-- 删除题目本身
DELETE FROM problem WHERE problem_id = :problem_id;

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, 'delete', 'problem', :problem_id, :description, :created_at);
```

---

### 2.3 比赛管理模块 (contests.py)

#### 2.3.1 创建比赛
**功能**：创建新比赛

**SQL语句**：
```sql
-- 插入新比赛
INSERT INTO contest (title, description, start_time, end_time, creator_id, problems_published)
VALUES (:title, :description, :start_time, :end_time, :creator_id, 0);

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, 'create', 'contest', :contest_id, :description, :created_at);
```

#### 2.3.2 为比赛添加题目
**功能**：将题目关联到比赛

**SQL语句**：
```sql
-- 查询比赛是否存在
SELECT * FROM contest WHERE contest_id = :contest_id;

-- 查询题目是否存在
SELECT * FROM problem WHERE problem_id = :problem_id;

-- 检查题目是否已关联到比赛
SELECT * FROM contest_problem 
WHERE contest_id = :contest_id AND problem_id = :problem_id;

-- 添加比赛-题目关联
INSERT INTO contest_problem (contest_id, problem_id)
VALUES (:contest_id, :problem_id);
```

#### 2.3.3 用户报名比赛
**功能**：用户注册参加比赛

**SQL语句**：
```sql
-- 查询比赛是否存在
SELECT * FROM contest WHERE contest_id = :contest_id;

-- 检查是否已报名
SELECT * FROM contest_user WHERE contest_id = :contest_id AND user_id = :user_id;

-- 添加报名记录
INSERT INTO contest_user (contest_id, user_id)
VALUES (:contest_id, :user_id);
```

#### 2.3.4 获取比赛列表
**功能**：查询比赛列表，支持筛选和分页

**SQL语句**：
```sql
-- 基础查询
SELECT * FROM contest
ORDER BY start_time DESC
LIMIT :limit OFFSET :offset;
```

#### 2.3.5 获取比赛详情
**功能**：查询比赛详细信息及关联题目

**SQL语句**：
```sql
-- 查询比赛信息
SELECT * FROM contest WHERE contest_id = :contest_id;

-- 查询比赛的题目列表
SELECT p.* FROM problem p
INNER JOIN contest_problem cp ON p.problem_id = cp.problem_id
WHERE cp.contest_id = :contest_id;

-- 查询用户在比赛中的提交统计
SELECT 
    s.problem_id,
    COUNT(s.submission_id) as total_submissions,
    SUM(CASE WHEN s.status = 'accepted' THEN 1 ELSE 0 END) as accepted_count
FROM submission s
INNER JOIN user_submission us ON s.submission_id = us.submission_id
WHERE us.user_id = :user_id AND s.contest_id = :contest_id
GROUP BY s.problem_id;
```

#### 2.3.6 发布比赛题目到公开题库
**功能**：比赛结束后将题目发布到公开题库

**SQL语句**：
```sql
-- 查询比赛信息
SELECT * FROM contest WHERE contest_id = :contest_id;

-- 查询比赛的所有题目
SELECT * FROM contest_problem WHERE contest_id = :contest_id;

-- 对于保留ID题目（ID<10000），需要迁移
SELECT * FROM problem WHERE problem_id = :old_problem_id;

-- 创建新题目（ID>=10000）
INSERT INTO problem (
    title, description, input_format, output_format,
    sample_input, sample_output, time_limit, memory_limit,
    difficulty, tags, creator_id, test_cases, visible
) VALUES (
    :title, :description, :input_format, :output_format,
    :sample_input, :sample_output, :time_limit, :memory_limit,
    :difficulty, :tags, :creator_id, :test_cases, 1
);

-- 更新提交记录的problem_id并转为题库提交
UPDATE submission SET problem_id = :new_problem_id, contest_id = NULL 
WHERE problem_id = :old_problem_id AND contest_id = :contest_id;

-- 更新其他提交的problem_id（不改变contest_id）
UPDATE submission SET problem_id = :new_problem_id 
WHERE problem_id = :old_problem_id AND (contest_id IS NULL OR contest_id != :contest_id);

-- 更新比赛-题目关联
UPDATE contest_problem SET problem_id = :new_problem_id 
WHERE contest_id = :contest_id AND problem_id = :old_problem_id;

-- 删除旧题目
DELETE FROM problem WHERE problem_id = :old_problem_id;

-- 标记比赛题目已发布
UPDATE contest SET problems_published = 1 WHERE contest_id = :contest_id;
```

#### 2.3.7 比赛排行榜
**功能**：计算比赛实时排名

**SQL语句**：
```sql
-- 查询比赛排行榜
SELECT 
    u.user_id,
    u.username,
    u.avatar,
    COUNT(DISTINCT CASE WHEN s.status = 'accepted' THEN s.problem_id END) as solved_count,
    SUM(s.exec_time) as total_time,
    MIN(s.submitted_at) as first_submission_time
FROM user u
INNER JOIN contest_user cu ON u.user_id = cu.user_id
INNER JOIN user_submission us ON u.user_id = us.user_id
INNER JOIN submission s ON us.submission_id = s.submission_id
WHERE cu.contest_id = :contest_id 
  AND s.contest_id = :contest_id
GROUP BY u.user_id, u.username, u.avatar
ORDER BY solved_count DESC, total_time ASC, first_submission_time ASC;
```

#### 2.3.8 删除比赛
**功能**：管理员删除比赛及相关数据

**SQL语句**：
```sql
-- 查询比赛信息
SELECT title FROM contest WHERE contest_id = :contest_id;

-- 删除比赛-题目关联
DELETE FROM contest_problem WHERE contest_id = :contest_id;

-- 删除比赛-用户关联
DELETE FROM contest_user WHERE contest_id = :contest_id;

-- 将比赛提交转为题库提交（保留提交记录）
UPDATE submission SET contest_id = NULL WHERE contest_id = :contest_id;

-- 删除比赛本身
DELETE FROM contest WHERE contest_id = :contest_id;

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, 'delete', 'contest', :contest_id, :description, :created_at);
```

---

### 2.4 提交记录模块 (submissions.py)

#### 2.4.1 创建提交记录
**功能**：用户提交代码并自动评测

**SQL语句**：
```sql
-- 检查题目是否存在
SELECT problem_id, title FROM problem WHERE problem_id = :problem_id;

-- 验证与协作用户是否为已接受的好友（协作提交场景）
SELECT 1 FROM friendship
WHERE ((user_id = :user_id AND friend_id = :collab_id) 
       OR (user_id = :collab_id AND friend_id = :user_id))
  AND status = 'accepted' LIMIT 1;

-- 如果为比赛题目，验证协作者是否报名该比赛
SELECT 1 FROM contest_user WHERE contest_id = :contest_id AND user_id = :user_id LIMIT 1;

-- 插入提交记录
INSERT INTO submission (
    problem_id, contest_id, code, language, status,
    exec_time, exec_memory, submitted_at
) VALUES (
    :problem_id, :contest_id, :code, :language, 'judging',
    0, 0, :submitted_at
);

-- 创建用户-提交关联
INSERT INTO user_submission (user_id, submission_id)
VALUES (:user_id, :submission_id);

-- 维护题目-提交关联（忽略重复，兼容历史数据）
CREATE TABLE IF NOT EXISTS problem_submission (
    problem_id INT NOT NULL,
    submission_id INT NOT NULL,
    PRIMARY KEY (problem_id, submission_id)
);
INSERT IGNORE INTO problem_submission (problem_id, submission_id)
VALUES (:problem_id, :submission_id);

-- 评测完成后更新提交状态
UPDATE submission
SET status = :status, exec_time = :exec_time, exec_memory = :exec_memory, judge_results = :judge_results
WHERE submission_id = :submission_id;

-- 记录活动日志
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, 'submit', 'submission', :submission_id, :description, :created_at);
```

#### 2.4.2 获取提交列表
**功能**：查询提交记录，支持筛选和分页

**SQL语句**：
```sql
-- 按题目筛选时，优先走 problem_submission，缺失时回退扫描 submission 并补齐映射
SELECT 1 FROM problem_submission WHERE problem_id = :problem_id LIMIT 1;
INSERT IGNORE INTO problem_submission (problem_id, submission_id)
SELECT :problem_id, submission_id FROM submission WHERE problem_id = :problem_id;  -- 仅在映射缺失时执行

SELECT s.*, us.user_id, p.title as problem_title
FROM problem_submission ps
INNER JOIN submission s ON ps.submission_id = s.submission_id
LEFT JOIN user_submission us ON s.submission_id = us.submission_id
LEFT JOIN problem p ON s.problem_id = p.problem_id
WHERE ps.problem_id = :problem_id
    AND (:contest_id IS NULL OR s.contest_id = :contest_id)
    AND (:status IS NULL OR s.status = :status)
ORDER BY s.submitted_at DESC
LIMIT :limit OFFSET :offset;

-- 未指定 problem_id 时，回退到原有联合查询
-- 基础查询（动态拼接条件）
SELECT s.*, us.user_id, p.title as problem_title
FROM submission s
INNER JOIN user_submission us ON s.submission_id = us.submission_id
LEFT JOIN problem p ON s.problem_id = p.problem_id
WHERE us.user_id = :user_id  -- 可选用户筛选
  AND s.problem_id = :problem_id  -- 可选题目筛选
  AND s.contest_id = :contest_id  -- 可选比赛筛选
  AND s.status = :status  -- 可选状态筛选
ORDER BY s.submitted_at DESC
LIMIT :limit OFFSET :offset;
```

#### 2.4.3 获取提交详情
**功能**：查询单个提交的详细信息

**SQL语句**：
```sql
-- 查询提交详情
SELECT s.*, us.user_id
FROM submission s
INNER JOIN user_submission us ON s.submission_id = us.submission_id
WHERE s.submission_id = :submission_id;

-- 查询题目信息
SELECT title FROM problem WHERE problem_id = :problem_id;

-- 查询用户信息
SELECT username FROM user WHERE user_id = :user_id;
```

#### 2.4.4 重新评测提交
**功能**：管理员重新评测某个提交

**SQL语句**：
```sql
-- 查询提交记录
SELECT * FROM submission WHERE submission_id = :submission_id;

-- 更新状态为评测中
UPDATE submission SET status = 'judging' WHERE submission_id = :submission_id;

-- 评测完成后更新
UPDATE submission
SET status = :status, exec_time = :exec_time, exec_memory = :exec_memory, judge_results = :judge_results
WHERE submission_id = :submission_id;
```

---

### 2.5 消息模块 (messages.py)

#### 2.5.1 创建消息
**功能**：创建话题讨论或私信

**SQL语句**：
```sql
-- 验证创建者存在
SELECT user_id FROM user WHERE user_id = :user_id;

-- 私信发送前检查接收者是否屏蔽了发送者
SELECT 1 FROM friendship
WHERE user_id = :recipient_id AND friend_id = :creator_id AND status = 'blocked'
LIMIT 1;

-- 校验双方是否已成为好友（仅互为 accepted 才能私信）
SELECT 1 FROM friendship
WHERE ((user_id = :creator_id AND friend_id = :recipient_id) 
       OR (user_id = :recipient_id AND friend_id = :creator_id))
  AND status = 'accepted' LIMIT 1;

-- 插入消息
INSERT INTO message (title, content, creator_id, message_type, created_at)
VALUES (:title, :content, :creator_id, :message_type, :created_at);

-- 添加消息-题目关联（话题讨论）
INSERT INTO message_problem (message_id, problem_id)
VALUES (:message_id, :problem_id);

-- 添加消息接收者（私信）
INSERT INTO message_recipient (message_id, recipient_user_id)
VALUES (:message_id, :recipient_user_id);
```

#### 2.5.2 获取消息列表
**功能**：查询消息列表

**SQL语句**：
```sql
-- 查询话题讨论列表
SELECT m.*, mp.problem_id, p.title as problem_title
FROM message m
LEFT JOIN message_problem mp ON m.message_id = mp.message_id
LEFT JOIN problem p ON mp.problem_id = p.problem_id
WHERE m.message_type = 'topic'
ORDER BY m.created_at DESC
LIMIT :limit OFFSET :offset;

-- 查询用户的私信列表
SELECT m.*
FROM message m
INNER JOIN message_recipient mr ON m.message_id = mr.message_id
WHERE mr.recipient_user_id = :user_id AND m.message_type = 'private'
ORDER BY m.created_at DESC
LIMIT :limit OFFSET :offset;
```

#### 2.5.3 可发送私信的候选接收者
**功能**：返回当前用户可发送私信的好友列表

**SQL语句**：
```sql
SELECT DISTINCT u.user_id, u.username, u.school, u.avatar, u.rating
FROM user u
INNER JOIN friendship f ON (
    (f.user_id = :user_id AND f.friend_id = u.user_id AND f.status = 'accepted')
    OR
    (f.friend_id = :user_id AND f.user_id = u.user_id AND f.status = 'accepted')
)
WHERE u.user_id != :user_id
ORDER BY u.username ASC;
```

#### 2.5.4 获取消息详情
**功能**：查询消息详细内容

**SQL语句**：
```sql
-- 查询消息信息
SELECT * FROM message WHERE message_id = :message_id;

-- 查询创建者信息
SELECT username, avatar FROM user WHERE user_id = :creator_id;

-- 查询关联的题目
SELECT p.* FROM problem p
INNER JOIN message_problem mp ON p.problem_id = mp.problem_id
WHERE mp.message_id = :message_id;
```

#### 2.5.5 删除消息
**功能**：删除消息及相关关联

**SQL语句**：
```sql
-- 查询消息
SELECT * FROM message WHERE message_id = :message_id;

-- 删除消息-题目关联
DELETE FROM message_problem WHERE message_id = :message_id;

-- 删除消息-接收者关联
DELETE FROM message_recipient WHERE message_id = :message_id;

-- 删除消息本身
DELETE FROM message WHERE message_id = :message_id;
```

---

### 2.6 好友管理模块 (friendships.py)

#### 2.6.1 发送好友请求
**功能**：用户向其他用户发送好友申请

**SQL语句**：
```sql
-- 检查目标用户是否存在
SELECT user_id FROM user WHERE user_id = :friend_id;

-- 检查是否已经是好友或有待处理的请求
SELECT * FROM friendship 
WHERE user_id = :user_id AND friend_id = :friend_id;

-- 检查对方是否屏蔽了自己
SELECT 1 FROM friendship 
WHERE user_id = :friend_id AND friend_id = :user_id AND status = 'blocked'
LIMIT 1;

-- 创建好友请求
INSERT INTO friendship (user_id, friend_id, status, created_at, updated_at)
VALUES (:user_id, :friend_id, 'pending', :created_at, :updated_at);

-- 如果之前被拒绝，重新发送请求
UPDATE friendship 
SET status = 'pending', updated_at = :updated_at
WHERE friendship_id = :friendship_id;
```

#### 2.6.2 接受/拒绝好友请求
**功能**：处理好友申请

**SQL语句**：
```sql
-- 查询好友请求
SELECT * FROM friendship WHERE friendship_id = :friendship_id;

-- 更新好友请求状态
UPDATE friendship 
SET status = :status, updated_at = :updated_at
WHERE friendship_id = :friendship_id;

-- 处理接受请求时：检查是否已经存在反向关系
SELECT friendship_id FROM friendship 
WHERE user_id = :user_id AND friend_id = :friend_id LIMIT 1;

-- 若反向关系存在，更新为 accepted
UPDATE friendship SET status = 'accepted', updated_at = NOW() 
WHERE friendship_id = :reverse_friendship_id;

-- 若反向关系不存在，则插入一条反向的 accepted 记录
INSERT INTO friendship (user_id, friend_id, status, created_at, updated_at)
VALUES (:user_id, :friend_id, 'accepted', NOW(), NOW());
```

#### 2.6.3 获取好友列表
**功能**：查询用户的好友

**SQL语句**：
```sql
-- 查询好友列表（双向查询）
SELECT u.user_id, u.username, u.avatar, u.rating, f.status
FROM friendship f
INNER JOIN user u ON (
    CASE 
        WHEN f.user_id = :user_id THEN u.user_id = f.friend_id
        ELSE u.user_id = f.user_id
    END
)
WHERE (f.user_id = :user_id OR f.friend_id = :user_id)
  AND f.status = 'accepted';
```

#### 2.6.4 删除好友
**功能**：解除好友关系

**SQL语句**：
```sql
-- 删除好友关系（双向）
DELETE FROM friendship 
WHERE (user_id = :user_id AND friend_id = :friend_id)
   OR (user_id = :friend_id AND friend_id = :user_id);
```

#### 2.6.5 屏蔽/取消屏蔽用户
**功能**：对指定用户进行屏蔽或取消屏蔽

**SQL语句**：
```sql
-- 通过 user_id 直接屏蔽（如果存在则 update，否则 insert）
SELECT * FROM friendship WHERE user_id = :user_id AND friend_id = :friend_id;

-- 若存在，执行
UPDATE friendship SET status = 'blocked', updated_at = NOW() 
WHERE friendship_id = :friendship_id;

-- 若不存在，执行
INSERT INTO friendship (user_id, friend_id, status, created_at, updated_at) 
VALUES (:user_id, :friend_id, 'blocked', NOW(), NOW());

-- 取消屏蔽（若对方与自己存在 accepted 关系则恢复为 accepted，否则删除记录）
SELECT * FROM friendship 
WHERE friendship_id = :friendship_id AND user_id = :user_id AND status = 'blocked';

-- 若查询到反向 accepted 记录，则
UPDATE friendship SET status = 'accepted', updated_at = NOW() 
WHERE friendship_id = :friendship_id;

-- 否则
DELETE FROM friendship WHERE friendship_id = :friendship_id;
```

---

### 2.7 测试用例管理模块 (test_cases_json.py)

**说明**：项目使用 JSON 模式存储测试用例，测试点数据保存在 `problem.test_cases` 字段中。

#### 2.7.1 读取测试用例
**功能**：获取题目的测试用例

**SQL语句**：
```sql
-- 读取题目的 test_cases 字段与创建者
SELECT test_cases, creator_id FROM problem WHERE problem_id = :problem_id;
```

#### 2.7.2 更新测试用例
**功能**：添加、修改或删除测试用例

**SQL语句**：
```sql
-- 将前端提交的 test_cases 数组整体写回到 problem.test_cases
UPDATE problem SET test_cases = :test_cases WHERE problem_id = :problem_id;
```

---

### 2.8 活动日志模块 (activity_logs.py)

#### 2.8.1 获取活动日志
**功能**：查询系统活动日志

**SQL语句**：
```sql
-- 查询日志列表
SELECT * FROM activity_log
ORDER BY created_at DESC
LIMIT :limit OFFSET :offset;

-- 查询日志对应的用户信息
SELECT username FROM user WHERE user_id = :user_id;
```

#### 2.8.2 记录活动日志
**功能**：添加新的活动日志记录

**SQL语句**：
```sql
-- 插入日志记录
INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
VALUES (:user_id, :action_type, :entity_type, :entity_id, :description, :created_at);
```

---

### 2.9 代码评测模块 (judge_engine.py / judge_runner.py)

#### 2.9.1 评测提交代码
**功能**：执行代码评测并更新结果

**SQL语句**：
```sql
-- 查询提交记录
SELECT * FROM submission WHERE submission_id = :submission_id;

-- 查询题目信息和测试用例
SELECT * FROM problem WHERE problem_id = :problem_id;

-- 更新评测结果
UPDATE submission
SET status = :status,
    exec_time = :exec_time,
    exec_memory = :exec_memory,
    judge_results = :judge_results
WHERE submission_id = :submission_id;
```

---

### 2.10 数据统计查询

#### 2.10.1 题目统计
**功能**：统计题目的提交数、通过率等

**SQL语句**：
```sql
-- 查询题目的总提交数
SELECT COUNT(*) as total_submissions
FROM submission
WHERE problem_id = :problem_id AND contest_id IS NULL;

-- 查询题目的通过数
SELECT COUNT(*) as accepted_count
FROM submission
WHERE problem_id = :problem_id 
  AND contest_id IS NULL
  AND status = 'accepted';

-- 查询题目的通过率
SELECT 
    COUNT(*) as total,
    SUM(CASE WHEN status = 'accepted' THEN 1 ELSE 0 END) as accepted,
    ROUND(SUM(CASE WHEN status = 'accepted' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as pass_rate
FROM submission
WHERE problem_id = :problem_id AND contest_id IS NULL;
```

#### 2.10.2 用户难度分布
**功能**：统计用户解决各难度题目的数量

**SQL语句**：
```sql
SELECT 
    p.difficulty,
    COUNT(DISTINCT s.problem_id) as count
FROM submission s
INNER JOIN user_submission us ON s.submission_id = us.submission_id
INNER JOIN problem p ON s.problem_id = p.problem_id
WHERE us.user_id = :user_id 
  AND s.status = 'accepted'
  AND s.contest_id IS NULL
GROUP BY p.difficulty;
```

---

## 3. 触发器与存储过程

### 3.1 设计说明

本项目**未使用数据库触发器（TRIGGER）和存储过程（STORED PROCEDURE）**，而是采用**应用层实现**的方式完成所有业务逻辑。这是基于以下设计考虑：

#### 3.1.1 架构选择原因

**优势**：
1. **可维护性**：业务逻辑集中在应用代码中，便于开发、调试和版本控制
2. **可移植性**：不依赖特定数据库的存储过程语法，易于迁移到其他数据库系统
3. **可测试性**：应用层逻辑可以使用单元测试和集成测试框架进行完整测试
4. **开发效率**：Python代码比SQL存储过程更易于编写和维护，IDE支持更完善
5. **权限管理**：应用层可以实现更细粒度的权限控制和业务规则验证

**劣势**：
1. **网络开销**：复杂事务需要多次数据库往返，增加网络延迟
2. **原子性控制**：需要显式管理事务边界，确保数据一致性
3. **性能优化**：某些批量操作在数据库端执行可能更高效

**项目选择**：考虑到本项目为**在线判题系统**，具有以下特点：
- 业务逻辑复杂，需要频繁迭代和维护
- 数据量相对可控，单次操作涉及的数据记录较少
- 需要与评测引擎、文件系统等外部资源交互
- 开发团队更熟悉Python生态

因此，**应用层实现**是更合适的架构选择。

---

### 3.2 等价实现方式

本节说明传统数据库触发器和存储过程的功能如何在应用层实现。

#### 3.2.1 活动日志记录（触发器的等价实现）

**传统触发器实现**：
```sql
-- 假设使用触发器自动记录用户删除事件
DELIMITER //
CREATE TRIGGER after_user_delete
AFTER DELETE ON user
FOR EACH ROW
BEGIN
    INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
    VALUES (OLD.user_id, 'delete', 'user', OLD.user_id, 
            CONCAT('用户 ', OLD.username, ' 被删除'), NOW());
END //
DELIMITER ;
```

**本项目的应用层实现**：

在每个需要记录日志的操作中，**显式调用日志插入逻辑**。

**代码位置**：`backend/app/routers/users.py` (第257行)

```python
# 删除用户后记录活动日志
insert_log_sql = """
    INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
    VALUES (:user_id, :action_type, :entity_type, :entity_id, :description, :created_at)
"""
execute_insert(db, insert_log_sql, {
    "user_id": current_user.user_id,
    "action_type": "delete",
    "entity_type": "user",
    "entity_id": user_id,
    "description": f"管理员 {current_user.username} 删除了用户 {db_user['username']}",
    "created_at": datetime.utcnow()
})
```

**覆盖范围**：项目中所有关键操作均记录活动日志，包括：
- 用户注册、删除 (`users.py`)
- 题目创建、更新、删除 (`problems.py`)
- 比赛创建、发布、删除 (`contests.py`)
- 提交代码 (`submissions.py`)
- 消息创建、删除 (`messages.py`)

**优势**：
- 日志内容可以包含更丰富的上下文信息（如操作者姓名）
- 可以灵活决定哪些操作需要记录日志
- 日志记录失败不会影响主要业务逻辑（可用try-except捕获）

---

#### 3.2.2 级联删除（触发器的等价实现）

**传统触发器实现**：
```sql
-- 假设使用触发器实现用户删除时的级联清理
DELIMITER //
CREATE TRIGGER before_user_delete
BEFORE DELETE ON user
FOR EACH ROW
BEGIN
    -- 删除用户的提交关联
    DELETE FROM user_submission WHERE user_id = OLD.user_id;
    -- 删除比赛参与记录
    DELETE FROM contest_user WHERE user_id = OLD.user_id;
    -- 删除好友关系
    DELETE FROM friendship WHERE user_id = OLD.user_id OR friend_id = OLD.user_id;
END //
DELIMITER ;
```

**本项目的应用层实现**：

在删除用户时，**按顺序执行级联删除操作**。

**代码位置**：`backend/app/routers/users.py` (第180-250行)

```python
# 1. 获取用户的所有提交ID
get_submissions_sql = "SELECT submission_id FROM user_submission WHERE user_id = :user_id"
submissions = execute_query(db, get_submissions_sql, {"user_id": user_id})
submission_ids = [s['submission_id'] for s in submissions]

# 2. 删除用户-提交关联
delete_user_sub_sql = "DELETE FROM user_submission WHERE user_id = :user_id"
execute_update(db, delete_user_sub_sql, {"user_id": user_id})

# 3. 删除提交记录
if submission_ids:
    placeholders = ','.join([':id' + str(i) for i in range(len(submission_ids))])
    delete_submissions_sql = f"DELETE FROM submission WHERE submission_id IN ({placeholders})"
    params = {f'id{i}': sid for i, sid in enumerate(submission_ids)}
    execute_update(db, delete_submissions_sql, params)

# 4. 删除比赛参与记录
delete_contest_user_sql = "DELETE FROM contest_user WHERE user_id = :user_id"
execute_update(db, delete_contest_user_sql, {"user_id": user_id})

# 5. 删除好友关系
delete_friendship_sql = """
    DELETE FROM friendship 
    WHERE user_id = :user_id OR friend_id = :user_id
"""
execute_update(db, delete_friendship_sql, {"user_id": user_id})

# 6. 删除用户本身
delete_user_sql = "DELETE FROM user WHERE user_id = :user_id"
execute_update(db, delete_user_sql, {"user_id": user_id})
```

**类似实现**：
- **题目删除级联** (`problems.py` 第365-395行)：删除提交记录、比赛关联、消息关联
- **比赛删除级联** (`contests.py` 第960-990行)：删除题目关联、用户关联，并将提交转为题库提交
- **消息删除级联** (`messages.py` 第545-570行)：删除题目关联、接收者关联

**优势**：
- 删除顺序可控，便于处理复杂的外键依赖关系
- 可以在删除前备份数据或执行其他业务逻辑
- 删除过程可以记录详细日志用于审计

---

#### 3.2.3 数据验证与约束（触发器的等价实现）

**传统触发器实现**：
```sql
-- 假设使用触发器验证比赛时间的合法性
DELIMITER //
CREATE TRIGGER before_contest_insert
BEFORE INSERT ON contest
FOR EACH ROW
BEGIN
    IF NEW.end_time <= NEW.start_time THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = '比赛结束时间必须晚于开始时间';
    END IF;
END //
DELIMITER ;
```

**本项目的应用层实现**：

使用**Pydantic模型验证**和**业务逻辑检查**。

**代码位置**：`backend/app/schemas.py`

```python
from pydantic import BaseModel, validator

class ContestCreate(BaseModel):
    title: str
    description: str
    start_time: datetime
    end_time: datetime
    
    @validator('end_time')
    def validate_end_time(cls, v, values):
        if 'start_time' in values and v <= values['start_time']:
            raise ValueError('比赛结束时间必须晚于开始时间')
        return v
```

**其他验证示例**：

1. **好友关系验证** (`friendships.py` 第28-35行)：
```python
# 检查对方是否屏蔽了自己
check_blocked_sql = """
    SELECT 1 FROM friendship 
    WHERE user_id = :friend_id AND friend_id = :user_id AND status = 'blocked'
    LIMIT 1
"""
blocked = fetch_one(db, check_blocked_sql, {"friend_id": friend_id, "user_id": current_user.user_id})
if blocked:
    raise HTTPException(status_code=403, detail="无法添加该用户为好友")
```

2. **协作提交验证** (`submissions.py` 第90-110行)：
```python
# 验证协作用户是否为已接受的好友
verify_friendship_sql = """
    SELECT 1 FROM friendship
    WHERE ((user_id = :user_id AND friend_id = :collab_id) 
           OR (user_id = :collab_id AND friend_id = :user_id))
      AND status = 'accepted' LIMIT 1
"""
friendship = fetch_one(db, verify_friendship_sql, {
    "user_id": current_user.user_id, 
    "collab_id": collab_user_id
})
if not friendship:
    raise HTTPException(status_code=400, detail="协作用户必须是已接受的好友")
```

**优势**：
- 验证逻辑更灵活，可以调用外部服务或复杂算法
- 错误信息更友好，可以返回详细的验证失败原因
- 验证规则可以动态调整，无需修改数据库

---

#### 3.2.4 复杂事务处理（存储过程的等价实现）

**传统存储过程实现**：
```sql
-- 假设使用存储过程发布比赛题目到题库
DELIMITER //
CREATE PROCEDURE publish_contest_problems(IN contest_id INT, IN admin_id INT)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE old_problem_id INT;
    DECLARE new_problem_id INT;
    DECLARE cur CURSOR FOR SELECT problem_id FROM contest_problem WHERE contest_id = contest_id;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    START TRANSACTION;
    
    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO old_problem_id;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 如果是保留ID题目，需要迁移
        IF old_problem_id < 10000 THEN
            -- 创建新题目（ID>=10000）
            INSERT INTO problem (...) SELECT ... FROM problem WHERE problem_id = old_problem_id;
            SET new_problem_id = LAST_INSERT_ID();
            
            -- 更新提交记录
            UPDATE submission SET problem_id = new_problem_id 
            WHERE problem_id = old_problem_id AND contest_id = contest_id;
            
            -- 删除旧题目
            DELETE FROM problem WHERE problem_id = old_problem_id;
        END IF;
    END LOOP;
    CLOSE cur;
    
    -- 标记比赛题目已发布
    UPDATE contest SET problems_published = 1 WHERE contest_id = contest_id;
    
    COMMIT;
END //
DELIMITER ;
```

**本项目的应用层实现**：

使用**应用层事务管理**和**循环处理**。

**代码位置**：`backend/app/routers/contests.py` (第560-680行)

```python
@router.post("/{contest_id}/publish-problems", status_code=200)
def publish_contest_problems_to_library(
    contest_id: int,
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """将比赛题目发布到公开题库（管理员）"""
    if current_user.role != 'admin':
        raise HTTPException(status_code=403, detail="权限不足")
    
    # 查询比赛信息
    contest_sql = "SELECT * FROM contest WHERE contest_id = :contest_id"
    contest = fetch_one(db, contest_sql, {"contest_id": contest_id})
    if not contest:
        raise HTTPException(status_code=404, detail="比赛不存在")
    
    # 检查比赛题目是否已发布
    if contest['problems_published']:
        raise HTTPException(status_code=400, detail="比赛题目已经发布过")
    
    # 查询比赛的所有题目
    contest_problems_sql = "SELECT * FROM contest_problem WHERE contest_id = :contest_id"
    contest_problems = execute_query(db, contest_problems_sql, {"contest_id": contest_id})
    
    problem_id_mapping = {}  # 旧ID -> 新ID的映射
    
    try:
        for cp in contest_problems:
            old_problem_id = cp['problem_id']
            
            # 如果题目ID<10000（保留ID），需要迁移到新ID
            if old_problem_id < 10000:
                # 查询旧题目信息
                old_problem_sql = "SELECT * FROM problem WHERE problem_id = :problem_id"
                old_problem = fetch_one(db, old_problem_sql, {"problem_id": old_problem_id})
                
                if not old_problem:
                    continue
                
                # 创建新题目（ID>=10000，自动递增）
                insert_new_problem_sql = """
                    INSERT INTO problem (
                        title, description, input_format, output_format,
                        sample_input, sample_output, time_limit, memory_limit,
                        difficulty, tags, creator_id, test_cases, visible
                    ) VALUES (
                        :title, :description, :input_format, :output_format,
                        :sample_input, :sample_output, :time_limit, :memory_limit,
                        :difficulty, :tags, :creator_id, :test_cases, 1
                    )
                """
                new_problem_id = execute_insert(db, insert_new_problem_sql, {
                    "title": old_problem['title'],
                    # ... 其他字段
                })
                
                problem_id_mapping[old_problem_id] = new_problem_id
                
                # 更新提交记录的problem_id，并将contest_id设为NULL
                update_submissions_sql = """
                    UPDATE submission SET problem_id = :new_problem_id, contest_id = NULL 
                    WHERE problem_id = :old_problem_id AND contest_id = :contest_id
                """
                execute_update(db, update_submissions_sql, {
                    "new_problem_id": new_problem_id,
                    "old_problem_id": old_problem_id,
                    "contest_id": contest_id
                })
                
                # 删除旧题目
                delete_old_problem_sql = "DELETE FROM problem WHERE problem_id = :problem_id"
                execute_update(db, delete_old_problem_sql, {"problem_id": old_problem_id})
        
        # 标记比赛题目已发布
        update_contest_sql = """
            UPDATE contest SET problems_published = 1 WHERE contest_id = :contest_id
        """
        execute_update(db, update_contest_sql, {"contest_id": contest_id})
        
        # 记录活动日志
        insert_log_sql = """
            INSERT INTO activity_log (user_id, action_type, entity_type, entity_id, description, created_at)
            VALUES (:user_id, :action_type, :entity_type, :entity_id, :description, :created_at)
        """
        execute_insert(db, insert_log_sql, {
            "user_id": current_user.user_id,
            "action_type": "publish",
            "entity_type": "contest",
            "entity_id": contest_id,
            "description": f"管理员 {current_user.username} 发布了比赛 {contest['title']} 的题目到题库",
            "created_at": datetime.utcnow()
        })
        
        db.commit()
        return {
            "message": "比赛题目已成功发布到题库",
            "problem_id_mapping": problem_id_mapping
        }
    
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"发布题目失败: {str(e)}")
```

**其他复杂事务示例**：
- **代码评测流程** (`submissions.py` + `judge_engine.py`)：创建提交、执行评测、更新结果
- **比赛排行榜计算** (`contests.py` 第755-830行)：聚合多个用户的提交统计

**优势**：
- 可以在事务中调用外部服务（如评测引擎、文件上传）
- 错误处理更灵活，可以rollback并返回详细错误信息
- 业务逻辑可以使用Python的丰富库和工具

---

#### 3.2.5 事务管理机制

本项目使用**SQLAlchemy的事务管理**确保数据一致性。

**数据库会话管理** (`database.py` 第32-39行)：
```python
def get_db():
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**事务提交与回滚** (在各路由中使用)：
```python
try:
    # 执行多个数据库操作
    execute_insert(db, sql1, params1)
    execute_update(db, sql2, params2)
    execute_update(db, sql3, params3)
    
    # 提交事务
    db.commit()
    return {"message": "操作成功"}
    
except Exception as e:
    # 发生错误时回滚
    db.rollback()
    raise HTTPException(status_code=500, detail=f"操作失败: {str(e)}")
```

**事务隔离级别**：
- 使用MySQL默认的**REPEATABLE READ**隔离级别
- 通过`pool_pre_ping=True`确保连接可用性
- 设置连接超时防止死锁

---

### 3.3 性能优化措施

虽然没有使用存储过程，但通过以下方式优化性能：

#### 3.3.1 批量操作优化

**示例：批量删除提交记录** (`users.py` 第215-220行)
```python
if submission_ids:
    # 使用IN子句进行批量删除，减少数据库往返
    placeholders = ','.join([':id' + str(i) for i in range(len(submission_ids))])
    delete_submissions_sql = f"DELETE FROM submission WHERE submission_id IN ({placeholders})"
    params = {f'id{i}': sid for i, sid in enumerate(submission_ids)}
    execute_update(db, delete_submissions_sql, params)
```

#### 3.3.2 索引优化

**数据库索引定义** (`models.py`)：
```python
# 用户表索引
from sqlalchemy import Index

class User(Base):
    __tablename__ = "user"
    # ... 字段定义 ...
    
    __table_args__ = (
        Index('idx_username', 'username'),
        Index('idx_email', 'email'),
        Index('idx_created_at', 'created_at'),
    )
```

#### 3.3.3 连接池配置

**数据库连接池** (`database.py` 第10-23行)：
```python
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,        # 自动检测连接可用性
    pool_recycle=3600,          # 每小时回收连接
    connect_args={
        'connect_timeout': 10,  # 连接超时
        'read_timeout': 60,     # 读超时
        'write_timeout': 60,    # 写超时
    },
)
```

---

### 3.4 总结

本项目采用**应用层实现**替代传统的数据库触发器和存储过程，具有以下特点：

| 功能类型 | 传统实现 | 本项目实现 | 代码位置 |
|---------|---------|----------|---------|
| **活动日志记录** | AFTER触发器 | 显式插入日志 | 各router文件中的INSERT INTO activity_log |
| **级联删除** | BEFORE触发器 | 顺序执行DELETE语句 | users.py, problems.py, contests.py |
| **数据验证** | BEFORE触发器 | Pydantic验证 + 业务检查 | schemas.py, 各router文件 |
| **复杂事务** | 存储过程 | 应用层事务管理 | contests.py (发布题目), submissions.py (评测) |
| **批量操作** | 存储过程 | Python循环 + 批量SQL | users.py, contests.py |
